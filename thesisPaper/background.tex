\chapter{Background}
\label{back}

This chapter gives the background information necessary to understand what advantages function rank has in exploiting data parallelism over other approaches.

\section{Function Rank}
\subsection{History and Definition}
\textit{Function rank} was first developed and described by K. Iverson in a series of research reports written at IBM. % TODO cite
In one such report, Iverson described it as 
``the most important notion needed to provide a simple and systematic basis for the uniform treatment of all `mixed' or non-scalar functions.''\cite{rapl} % TODO footnote of next comment
Since that time, the idea of function rank has matured and found its way into many dialects of APL, including J.

J's model of function rank is slightly different from what was first presented by Iverson. \cite{rankanduni} \cite{jvocab}
The rank of a function \textit{f} in J is a vector \textit{v} of three values representing the data rank of \textit{f}'s expected arguments.
Since in J functions take either one or two arguments, the first value of \textit{v} represents the expected data rank of \textit{f}'s one-argument case (in J referred to as the \textit{monadic} case);
the second and third values in \textit{v} represent the expected data rank of \textit{f's} two-argument (\textit{dyadic}) case.
If \textit{f} has no restrictions on some or all of its arguments, this is represented in \textit{v} with the value for infinity, spelled \ttfamily \_ \normalfont ;
if \textit{f} operates on scalar values, this is represented as an entry in \textit{v} of 0 (in J, scalars are collections of rank 0 and an empty extent). % TODO make footnote

So, for example, most arithmetic functions, such as addition, fundamentally operate on scalar values and must be extended to operate on collections of rank \textit{n} $\ge$ 1.
On the other hand, most collective operations, such as indexing, operate on whole collections at once.

\subsection{Shape Agreement}
In the trivial cases, where a function \textit{f} is given arguments with ranks matching \textit{f}'s function rank, J behaves much like any programming language without function rank.
\begin{verbatim}
   1 + 1
2
   ] mat2_3 =: (integers =: i.) 2 3
0 1 2
3 4 5
   1 (from =: {) mat2_3
3 4 5
\end{verbatim}

In some cases, when the arguments to \textit{f} do not match its function rank, \textit{f} is automatically extended to the appropriate dimensions.
For example, \textit{x} is a scalar, addition can always be extended so that \textit{x} is added to every element of a collection \textit{c}, not matter \textit{c}'s rank or extent. % TODO use math mode
\begin{verbatim}
   1 + mat2_3
1 2 3
4 5 6
\end{verbatim}

In general, addition (and all other scalar functions) can be extended over two regular collections $x$ and $y$ of numeric values if the shape of one collection \textit{prefixes} the other.
This is called \textit{prefix shape agreement}, or just \textit{shape agreement},\cite{rankanduni} 
and in this paper we will say when this happens that ``the shapes of $x$ and $y$ agree under addition.''

Going back to the above example: a scalar, a vector of 2, and another 2 by 3 matrix will aggree with $mat2\_3$ under addition, since the shape of these prefixes the shape of $mat2\_3$; 
any collection of rank $n \ge 2$ whose shape begins with $2$ $3$ will also aggree with $mat2\_3$ under addition, since $mat2\_3$ would prefix it.

\begin{verbatim}
   3.141 2.718 + mat2_3
3.141 4.141 5.141
5.718 6.718 7.718
   mat2_3 + mat2_3
0 2  4
6 8 10
   ] arr2_3_2 =: integers 2 3 2
 0  1
 2  3
 4  5

 6  7
 8  9
10 11
   arr2_3_2 + mat2_3
 0  1
 3  4
 6  7

 9 10
12 13
15 16
\end{verbatim}

\subsection{Rank Operator}

\subection{Inherrent Data Parallelism}

\section{Other Solutions}
\subsection{Single Assignment C}

\subsection{MATLAB}

\subsection{Regular Extent Parallel Arrays in Haskel}
