\chapter{Introduction}
Many scientific and business computing applications work on large data sets naturally structured in regular, multidimensional collections.
In many languages, these multidimensional collections are implemted as nested collections; e.g. a 2-dimensional array of integers would be implemented as an array of arrays of integers.
However, irregular multidimensional collections are also usually implemented as nested collections, with each of the sub-arrays containing a different number of elements.
Thus, when implemented as such, it can be difficult to distinguish regular from irregular multidimensional collections, especially statically, which may lead to a run-time indexing errors and a program crash.

\textit{Data parallelism} is an approach to exploiting program concurrency by updating elements or subsections of collections in parallel.
Frequently, extending existing programs to large collections in a data-parallel fashion leads to what is know as "embarrasingly parallel" problems - that is, problems in which concurrency, and thus gains in performance, are achieved with little programmer effort.%TODO cite embarassing or data parallel or Hillis Steele? TODO fix quotes
One such extension is taking existing programs which operate on scalars (dimensionless values) or collections of fixed dimension and applying them to collections of higher dimensions.

In most imperative languages with regular multidimensional collections, applying programs to elements or sub-collections of a collection means writing the program call within nested looping structures, typically a \textit{for loop}
This usually means that number of dimensions of the collection determines the number of loops required to do a specific operation.
To put it another way, if an existing program needs to be extended to a collection of higher dimensions, or if the program only operates on scalar values but needs to be extended to some multidimensional collection, the programmer usually must wrap the program in nested for loops.
This activity is tedious in the trivial cases and prone to error when the extension is more complicated.
Above all, it is frequently difficult to do automatically without changing the existing code.

Functional programming languages allow programmers to view and write programs at a higher level of abstraction.
When dealing with collections, this usually means that related types of operations can be expressed as \textit{higher-order} functions like \textit{map} and \textit{reduce} which take functions as their arguments and return functions which operate on collections.
These higher-order functions often allow programmers to more easily understand what operations are being done to multidimensional collections than if the same operations were done imperatively using for loops.
However, since these higher-order functions are usually designed to return functions which operate on 1-dimensional collections, they too must be nested in order to extend existing functions to collections of higher dimension, with the same problems mentioned above.

\textit{Function rank} extends the notion of data rank to functions.\begin{comment}TODO cite\end{comment}
Data rank is simply the number of dimensions of a regular dataset - scalar values are said to be rank 0, and an \textit{n}-dimensional array is an array of rank n.
Thus, the rank of some regular dataset is usually a non-negative integer.
Function rank is a collection of each of the associated rank values of a function's expected arguments, usually with some value to represent when the function can take data of any rank for a specific argument.
In functional languages where the idea of function rank is formalized, extending existing functions to regular collections of higher dimension can be expressed as a single higher-order function application, instead of nesting.
This makes it easier for a programmer to write such extensions safely, quickly, and in an inherrently parallel fashion.
In some cases, such extensions are so trivial that the programmer need not modify the code at all, meaning this can also be done automatically.


%For example, a profits report over \it{n} years of 4 quarters of 3 months could be represented as a 3-dimensional array with extents \it{n 4 3};\begin{comment}TODO cite rank\end{comment} cellular automata like Conway's "Game of Life"\begin{comment}TODO cite Conway\end{comment} might be represented on an \it{n} by \it{m} grid - a 2-dimensional array with extents \it{n m}.
%In C, the profits report might be declared with \begin{verbatim}int report[n][4][3]\end{verbatim}; in Scala, 
